---
alwaysApply: true
---
You are tasked with extending the KINSO Stores POS System within an existing Next.js 15 project using the App Router, TypeScript, Ant Design (v5), Tailwind CSS v4, Redux Toolkit with RTK Query, and MongoDB with Mongoose. The system has a feature-based architecture, JWT-based authentication, role-based access control (RBAC), and a well-defined UI theme. Your goal is to implement the features listed below while adhering to the existing folder structure, coding standards, UI theme, and security practices. You may simplify or remove any feature or model if it conflicts with existing logic or introduces unnecessary complexity, but justify any changes in code comments. Ensure all code is type-safe, modular, and maintainable, leveraging existing patterns (e.g., feature slices, repository pattern, custom hooks).
Existing Setup:  

Folder Structure:  
/app: Next.js App Router pages and API routes.  
/components: Reusable React components.  
/features: Feature-based organization (e.g., /features/auth, /features/users).  
/lib: Database connection, Mongoose setup, and utilities.  
/store: Redux Toolkit and RTK Query setup.  
/types: Centralized and feature-specific TypeScript types.  
/styles: Tailwind CSS with custom global styles.


Backend:  
Next.js 15 API Routes in /app/api.  
MongoDB with Mongoose for data management.  
JWT-based authentication with refresh tokens (HTTP-only cookies).  
RBAC with roles: admin, manager, staff.  
Custom middleware for route protection (/middleware.ts).  
Centralized error handling via /store/baseQueryWithErrorHandling.ts.


Frontend:  
React 19 with TypeScript.  
Ant Design (v5) with custom theme (Montserrat font, Tailwind CSS variables).  
Redux Toolkit with RTK Query for state and API management.  
React Hot Toast for notifications.


Coding Standards:  
Strict TypeScript with comprehensive type definitions.  
ESLint with Next.js core web vitals and TypeScript rules (/eslint.config.mjs).  
Prettier for code formatting.  
Feature slices for modular architecture.  
Repository pattern for data operations.  
Custom hooks for reusable logic (e.g., debounce, modals).


Security:  
JWT tokens with bcryptjs for password hashing.  
Rate limiting and session validation.  
Input validation and sanitization in API routes.


Instructions:  

Implement the features in the order listed below, following the prioritized to-do list.  
Respect the existing folder structure (e.g., API routes in /app/api/[feature], components in /components, types in /types or /features/[feature]/types.ts).  
Use Ant Design (v5) components and Tailwind CSS v4 for styling, ensuring consistency with the existing theme (Montserrat font, custom color palette).  
Leverage RTK Query for API interactions, placing endpoints in /features/[feature]/api.ts.  
Secure API routes with JWT checks and RBAC using existing middleware.  
Use Mongoose for MongoDB operations, adding indexes for performance.  
Validate inputs and enforce schema constraints (e.g., unique fields).  
Write type-safe code with TypeScript interfaces in /types or feature-specific files.  
Reuse existing custom hooks (e.g., for modals, notifications) and create new ones as needed.  
If a feature or model (e.g., WarehouseID, complex demand algorithm) conflicts with existing logic, propose a simplified alternative (e.g., merge WarehouseID with OutletID) and document the change in code comments.  
Update /API_DOCUMENTATION.md with new endpoints.  
Test each feature for functionality, UI consistency, and performance using Jest (/tests).